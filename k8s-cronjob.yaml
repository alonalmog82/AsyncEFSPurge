apiVersion: batch/v1
kind: CronJob
metadata:
  name: efs-purge
  namespace: default
spec:
  # Run daily at 2 AM UTC
  schedule: "0 2 * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  
  jobTemplate:
    spec:
      backoffLimit: 2
      activeDeadlineSeconds: 7200  # 2 hour timeout
      
      template:
        metadata:
          labels:
            app: efspurge
            version: "1.0.0"
        
        spec:
          restartPolicy: OnFailure
          
          # Security context
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            fsGroup: 1000
          
          containers:
          - name: efspurge
            image: ghcr.io/alonalmog82/asyncefspurge:1.9.0
            imagePullPolicy: IfNotPresent
            
            args:
              - /data  # Path is required positional argument, cannot be env var
            
            # Security context
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                  - ALL
            
            # Resource limits
            # Memory limit should be higher than --memory-limit-mb to allow overhead
            # Rule of thumb: Set --memory-limit-mb to 80% of Kubernetes memory limit
            # Example: 1Gi k8s limit â†’ --memory-limit-mb=800
            resources:
              requests:
                memory: "512Mi"   # Minimum memory guaranteed
                cpu: "500m"
              limits:
                memory: "1Gi"     # Hard limit (should be > --memory-limit-mb)
                cpu: "2000m"      # More CPU for better performance
            
            # Volume mounts
            volumeMounts:
            - name: efs-volume
              mountPath: /data
            - name: tmp
              mountPath: /tmp
            
            # Environment variables
            env:
            # Python runtime settings
            - name: PYTHONUNBUFFERED
              value: "1"
            - name: PYTHONDONTWRITEBYTECODE
              value: "1"
            # Application configuration (all configurable via env vars)
            - name: EFSPURGE_MAX_AGE_DAYS
              value: "30"
            - name: EFSPURGE_MEMORY_LIMIT_MB
              value: "800"
            - name: EFSPURGE_TASK_BATCH_SIZE
              value: "5000"
            - name: EFSPURGE_LOG_LEVEL
              value: "INFO"
            # Concurrency settings
            - name: EFSPURGE_MAX_CONCURRENCY_SCANNING
              value: "1000"
            - name: EFSPURGE_MAX_CONCURRENCY_DELETION
              value: "1000"
            - name: EFSPURGE_MAX_CONCURRENT_SUBDIRS
              value: "100"
            # Empty directory cleanup
            - name: EFSPURGE_REMOVE_EMPTY_DIRS
              value: "1"  # Enable empty directory cleanup
            # - name: EFSPURGE_MAX_EMPTY_DIRS_TO_DELETE
            #   value: "500"  # Optional: override default (0=unlimited)
          
          # Volumes
          volumes:
          - name: efs-volume
            persistentVolumeClaim:
              claimName: efs-pvc
          - name: tmp
            emptyDir: {}

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: efs-pvc
  namespace: default
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: efs-sc
  resources:
    requests:
      storage: 1Gi  # Placeholder, EFS doesn't enforce this

---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: efs-sc
provisioner: efs.csi.aws.com
parameters:
  provisioningMode: efs-ap
  fileSystemId: fs-12345678  # Replace with your EFS ID
  directoryPerms: "700"
  gidRangeStart: "1000"
  gidRangeEnd: "2000"
  basePath: "/purge-data"

